[{"id":1,"attributes":{"title":"マークダウンをReactのJSXに変換","content":"## remarkの利用\nReactであれば、マークダウンを渡すだけでJSXに変換される \"react-markdown\"が便利。\n\nしかし、今回はマークダウン内の一部の要素を途中で書き換えたかったので、\"remark\"を利用する。\n\n## ライブラリをインストール\n```\nnpm install unified remark-parse remark-rehype rehype-sanitize rehype-stringify\n```\n\n## JavaScriptのファイル内にimport\n```\nimport { unified } from \"unified\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype from \"remark-rehype\";\nimport rehypeSanitize from \"rehype-sanitize\";\nimport rehypeStringify from \"rehype-stringify\";\n```\n\n\n## マークダウンをJSXに変換してreturnする関数\nhtml変換後のデータを直接Reactに渡すと、JSXではなく文字列として認識される。\n\nそのため、dangerouslySetInnerHTMLを利用してJSXに埋め込むかたちでreturnする必要がある。\n```\nasync function convertMarkdownIntoHtml(markdown) {\n\n\tconst data = await unified()\n\t\t.use(remarkParse)\n\t\t.use(remarkRehype)\n\t\t.use(rehypeSanitize)\n\t\t.use(rehypeStringify)\n\t\t.process(markdown);\n\n\tconst html = data.value　#ここからreplaceを使い自由に要素を書き換えられる。\n    \n\treturn <div dangerouslySetInnerHTML={{ __html: html }}></div>;  #JSXに埋め込んでreturn\n}\n```","createdAt":"2022-07-05T19:02:18.818Z","updatedAt":"2022-07-15T02:01:09.304Z","publishedAt":"2022-07-05T19:36:33.320Z","tag1":"React.js","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"remarkを用いてマークダウンをJSXに変換しちゃおう。"}},{"id":4,"attributes":{"title":"CSSでスクロールバーをカスタマイズ","content":"## スクロールバーのプロパティ\n\n```\n::-webkit-scrollbar　#縦横幅の設定\n::-webkit-scrollbar-track　#背景部分\n::-webkit-scrollbar-thumb 　#スクロールバー本体\n```\n\n\n## プロパティの設定\n```\n::-webkit-scrollbar {\n\twidth: 10px;　#Y軸の横幅\n\theight: 10px;　#X軸の縦幅\n}\n\n::-webkit-scrollbar-track {\n\tbackground: #好みの色;\n}\n\n::-webkit-scrollbar-thumb {\n\tbackground: #好みの色;\n\tborder-radius: 50px;　#丸みを帯びさせる\n\tborder: solid 1px #好みの色;　背景色と同じ色にすると左右に隙間ができ、デフォルトのスクロールバーの形式に近づく \n}\n```\n","createdAt":"2022-07-06T23:55:38.217Z","updatedAt":"2022-07-15T02:01:22.353Z","publishedAt":"2022-07-06T23:56:04.602Z","tag1":"CSS","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"おしゃれなスクロールバーが作れるかも。"}},{"id":5,"attributes":{"title":"Next.jsでメタ要素の設定を簡単に","content":"## メタ要素の入力をComponent化する\n\n```\nimport Head from \"next/head\";\n\nexport default function MyHead({ url, type, title, description, image, children }) {\n\treturn (\n\t\t<Head>\n\t\t\t{url && <meta property=\"og:url\" content={url} />}　#URL\n\t\t\t{type && <meta property=\"og:type\" content={type} />}　#ページの種類 website or article\n\t\t\t{title && <meta property=\"og:title\" content={title} />}　#そのページのタイトル（サイトネームとは別）\n\t\t\t{image && <meta property=\"og:image\" content={image} />}　#サムネ\n\t\t\t{description && (　#ページの説明\n\t\t\t\t\t<>\n\t\t\t\t\t<meta property=\"og:description\" content={description} />\n\t\t\t\t\t<meta name=\"description\" content={description} />\n\t\t\t\t\t</>\n\t\t\t)}\n\t\t\t{children}　#子要素を含める\n\t\t</Head>\n\t);\n}\n```","createdAt":"2022-07-07T16:40:27.934Z","updatedAt":"2022-07-15T02:09:59.875Z","publishedAt":"2022-07-07T16:40:29.260Z","tag1":"Next.js","tag2":"SEO","tag3":null,"tag4":null,"tag5":null,"description":"ページごとにメタ要素を楽に設定できるComponent。"}},{"id":6,"attributes":{"title":"display: flexでサイドバーを作る","content":"## flexを使う理由\n固定的なサイドバーはgridで簡単に実装できる。\n\nしかし、今回はサイドバーを可変式にしたかったので、使い勝手のいいflexで実装する。\n\n## HTML\n```\ndiv class=\"flex\">　#親要素のflex\n\t<div class=\"sidebar\">sidebar</div>　#サイドバー\n\t<div class=\"content\">content</div>　#コンテンツ\n</div>\n```\n\n## CSS\n```\n.flex {\n\tdisplay: flex;　#親要素にflexを設定\n}\n\n.sidebar {\n\twidth: 300px;　#子要素のサイドバーの横幅を設定\n}\n\n.content {\n\tflex: 1;　#サイドバーで埋まらなかった親要素の余白をコンテンツのwidthに設定\n}\n\n```","createdAt":"2022-07-08T20:54:57.178Z","updatedAt":"2022-07-15T02:01:48.550Z","publishedAt":"2022-07-08T20:54:57.902Z","tag1":"CSS","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"使い勝手のいいflexでブログのサイドバーを実装する。"}},{"id":7,"attributes":{"title":"Framer motionでReactのマウスカーソルをカスタマイズする","content":"## 必要なライブラリのインストール\n```\nnpm install framer-motion @react-hook/mouse-position\n```\n\n## JavaScriptにimport\n```\nimport { motion } from \"framer-motion\";\nimport useMouse from \"@react-hook/mouse-position\"\n```\n\n## 必要なStateとRef\n```\nconst [cursorText, setCursorText] = useState(\"test\");　#テキスト保存用のstate\nconst [cursorVariant, setCursorVariant] = useState(\"default\");　#Framer Motionで変数を指定するときに使うstate\n\nconst ref = React.useRef(null);\n```\n\n## マウスの位置を取得\n```\nconst mouse = useMouse(ref, {　#importしたuseMouseを代入\n\tenterDelay: 100,　#カーソルの遅延度\n\tleaveDelay: 100,\n});\n\n#マウスの座標\nlet mouseX = 0;\nlet mouseY = 0;\n    \n#マウスが画面内にあるときに、その座標を代入\nif (mouse.x !== null) mouseX = mouse.clientX;\nif (mouse.y !== null) mouseY = mouse.clientY;\n```\n    \n## Framer motion用の変数\n```\nconst variants = {\n\tdefault: {　#animateの初期値\n\t\topacity: 0,\n\t\theight: 0,\n\t\twidth: 0,\n\t\tx: mouseX,　#ここで取得したマウス座標を設定する\n\t\ty: mouseY,\n\t\tfontSize: \"1rem\",\n\t},\n\n\tlink: {　#リンクホバー時にカーソルを拡大\n\t\topacity: 1,\n\t\theight: 50,\n\t\twidth: 50,\n\t\tx: mouseX,\n\t\ty: mouseY,\n\t\tfontSize: \"1.2rem\",　#フォントサイズの変更\n\t},\n\n\tspring: {　#transitionに設定するとバネのような挙動になる\n\t\tdamping: 10,　#バネの抵抗力　0だと永遠に振動する\n\t\tmass: 1,　#重力　値が高いほど無重力に\n\t},\n};\n```\n\n## 要素上でカーソルにエフェクトを加える関数\n```\nfunction mouseOverLink() {　#マウスホバー時\n\tsetCursorText(\"view\");　#カーソル内のテキストを設定\n\tsetCursorVariant(\"link\");　#variants内のカーソルのmotionを指定\n}\n\nfunction mouseLeave() {　#マウスが要素を離れた時\n\tsetCursorText(\"\");　#カーソル内のテキストをリセット\n\tsetCursorVariant(\"default\");　#カーソルのmotionをデフォルトへ戻す\n}\n```\n\n## Reactのレンダー部分\n```\nfunction MouseCursorLayout({ children }) {\n    \n    #...先ほどまでの要素を内部に組み込む\n\n\treturn (\n\t\t<div ref={ref}>　#refをhtmlに設定　※カーソルが機能するのはrefを設定したhtml内部のみ\n\n            #Framer motionの変数にvariantsを設定、animateにvariant指定用のstateを設定する\n\t\t\t<motion.div className=\"mouse-cursor\" variants={variants} animate={cursorVariant}>\n\t\t\t\t<div className=\"mouse-cursor-box\">\n\t\t\t\t\t<span className=\"mouse-cursor-text\">{cursorText}</span>　#カーソルに表示されるテキスト\n\t\t\t\t</div>\n\t\t\t</motion.div>\n\t\t\t{children}　#Componentとして渡した要素を表示する　メインコンテンツなど\n\t\t</div>\n\t);\n}\n```\n## CSSの設定\n```\n.mouse-cursor {\n\tz-index: 500;\n\tposition: fixed; #カーソルを画面上に固定\n\tdisplay: flex;\n\talign-content: center;\n\tjustify-content: center;\n\tleft: 0;\n\ttop: 0;\n\theight: 0px;\n\twidth: 0px;\n\tpointer-events: none; #下の要素をクリックできるようにカーソルイベントを無効化\n}\n\n.mouse-cursor-box {\n\tbackground-color: black; #背景色\n\tcolor: white; #テキスト色\n\tborder-radius: 50%;\n\twidth: 100%;\n\theight: 100%;\n\toverflow: hidden;\n    transform:translate(-50%,-50%)\n}\n\n.mouse-cursor-text {\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n```","createdAt":"2022-07-08T23:57:23.006Z","updatedAt":"2022-07-15T09:21:37.319Z","publishedAt":"2022-07-09T00:22:00.325Z","tag1":"FramerMotion","tag2":"Next.js","tag3":null,"tag4":null,"tag5":null,"description":"オリジナルカーソルでWEBサイトのデザイン性を高めてみよう。"}},{"id":8,"attributes":{"title":"Framer Motionでページ遷移のエフェクトを作る　#Next.js","content":"## ライブラリのインストールとimport\n\n```\nnpm install framer-motion\n```\n```\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { useRouter } from \"next/router\";#ページ遷移の検知に必要\n```\n\n## Next.js、_app.js内の実装\ncomponentの離脱を検知するためにAnimatePresenceで子要素を囲む\n```\nfunction MyApp({ Component, pageProps }) {\n\tconst router = useRouter();　#現在のページを検知するためにルートを読み込む\n\n\treturn ( \n\t\t<AnimatePresence exitBeforeEnter>#Componentの離脱を検知するためにexitBeforeEnterが必要\n\t\t\t<Component {...pageProps} key={router.asPath} />#ページ遷移を検知するために現在のURLをKeyに設定\n\t\t</AnimatePresence>\n\t);\n}\n```\n\n## Layout内の実装\nFramer Motionのアニメーションをcomponentに組み込む\n```\nexport default function Layout({ children }) {\n\treturn (\n\t\t<motion.div　#ページ遷移時のエフェクトを設定\n\t\t\tinitial={{ opacity: 0, y: 10 }}#ページ読み込み前\n\t\t\tanimate={{ opacity: 1, y: 0 }}#ページ読み込み完了後\n\t\t\texit={{ opacity: 0, y: 10 }}#ページ離脱時\n\t\t\ttransition={{ duration: 0.4 }}#アニメーションの時間\n\t\t>\n\t\t\t{children}\n\t\t</motion.div>\n\t);\n}\n```\n\n## pagesのcomponent内の実装\n先ほどのLayoutをページコンテンツの親コンポーネントに設定する。\n```\nimport Layout from \"./保存先\"\n\nexport default function Home() {\n\treturn (\n\t\t<Layout>\n\t\t\t<div>Content</div>#ページ内に表示されるコンテンツ\n\t\t</Layout>\n\t);\n}\n```","createdAt":"2022-07-10T00:11:15.969Z","updatedAt":"2022-07-16T06:04:36.376Z","publishedAt":"2022-07-10T00:36:07.136Z","tag1":"FramerMotion","tag2":"React.js","tag3":"Next.js","tag4":null,"tag5":null,"description":"ページ遷移エフェクトに必要な、AnimatePresenceの使い方を覚えてみる。"}},{"id":9,"attributes":{"title":"よく使うReactのSnippetsをまとめてみる　#VSCode","content":"## 含まれている拡張機能\n```\nES7+ React/Redux/React-Native snippets\n```\n\n## Snippets\n```\n- **imr**→　　import React from 'react'\n- **rfce**→\n　import React from 'react'\n\n　function functionName() {\n 　　return (\n　　<div>functionName</div>\n　　)\n　}\n\n- **imrr**→　　import { BrowserRouter as Router, Route, NavLink} from 'react-router-dom'\n\n- **nfn**→　　const functionName = (params) => { }\n- **enf**→　　export const functionName = (params) => { }\n- **ednf**→　　export default function functionName(params) { }\n\n- **uef**→\n　　useEffect(() => {\n\n　　　return () => {\n 　　}\n　　}, [])\n```","createdAt":"2022-07-13T04:01:01.119Z","updatedAt":"2022-07-15T03:24:38.408Z","publishedAt":"2022-07-13T04:01:02.011Z","tag1":"React.js","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"Reactで頻繁に使うVSCodeのSnippetsをまとめてみました。目指せ作業効率アップ。"}},{"id":10,"attributes":{"title":"TypeScriptの基礎とか色々","content":"## プリミティブ型の種類\n\n```\nstring　#文字列\nnumber　#数字\nboolean　#true ,false\nsymbol　#値が一意\nbigint　#numberで表すことができない大きな数字\nnull　#値が存在していない\nundefined　#値が定義されてない\n```\n## 関数のデフォルトvalueについて\n引数をオプションにするには引数の後に**？**を使う。これによりtypeがundefinedでも許容されるようになる。\n```\nfunction hello(**name?: string**) { \n\tconsole.log(`Hello, ${name|| 'Anonymous'}!`);\n}\n```\n\nデフォルトvalueを設定する方法も有効、こちらの方が使い勝手が良さそう。\n\n```\nfunction hello(**name: string = 'Anonymous'** ) { \n\tconsole.log(`Hello, ${name}!`);\n}\n```\n\n\n## 関数、return型宣言\n\n```\nfunction hello(name) : **string** { # string型のreturnのみを許容する 何もreturnしない場合はvoidを割り当てる\n\treturn `Hello ${name}`\n}\n```\n\n## Arrayの型宣言\n\nフラットな配列の場合\n\n```\nlet names: **string[] **= ['string’, ’string'];\nlet names: **Array<string>** = ['string’, ’string'];\n```\n２次元配列の場合\n\n```\nlet names: **string[][]** = [[‘string’, ’string’], [‘string’, ’string’]];\n```\n\n## タプルの型宣言\n\nタプルは固定長なためarrayと異なりpushなどの拡張が不可。\n```\nlet tuple: **[string,number,boolean,undefined] **= ['string', 1, true, undefined];\n```\n\n## React Componentの型宣言\n```\nimport React, { **ReactNode** } from ‘react’\n\ntype Props = { **children : ReactNode }**\nconst Home: **React.FC<Props>** = ({ children }) => {\n```\n## useStateの型宣言\n```\nconst [cursorText, setCursorText] = useState**<string>**(“”); \nconst [cursorVariant, setCursorVariant] = useState**<string>**(“default\");\n```\n\n## タイプ名の宣言、Type Aliases\n### Array ver\n```\ntype TypeName = **[string, number, boolean]**\n```\n### Object ver\n```\ntype TypeName = {\n\t**name : string,** \n\t**age : number,** \n\t**male : boolean]**\n }\n```\n### Function ver\n```\ntype TypeName = **( a: number, b: number) => number**\n```\n### Typeの割り当て\n```\nArray : **TypeName** = [‘animal’, ’2’, ’true’]\nObject : **TypeName** = {\n\tname: ‘animal’,\n\tage: 2,\n\tmale: true\n}\nFunction : **TypeName** (a, b) {\n\treturn a + b\n}\n```\n## ジェネリック型\nTの部分がType割り当て時に宣言する型名として認識される。\n\n\n### 型宣言\n```\ntype TypeName = {\n　**parents: [T, T], mate: T, children: T[]**\n};\n```\n### 型割り当て\n```\nconst object: TypeName**<指定する型名 ex. string, >** = {\n\tparents: **[指定された型名,指定された型名]**,\n\tmate: **指定された型名**,\n\tchildren: **指定された型名[]**\n}\n```\n### Functionでの型宣言\n```\nfunction getFilledArray**<T>(value: T, n: number): T[]** {\n　return Array(n).fill(value);\n}\n```\n### Functionの呼び出し、関数名の後ろで型を指定\n```\ngetFilledArray**<string>**('text', 4)\n```\n\n## Union タイプの型宣言\n\n複数のtypeを指定するには型宣言時に **|** でtype同士を接続する。\n\n```\nlet union : **string | number**;\n```\n### 混合型arrayの型宣言\n\n\n```\nconst unionArray : **( string | number )[] = [**‘string’, 0**]**\n```\n\n### Literalタイプの型宣言\n\n```\ntype Color = 'green' | 'yellow' | 'red';\n\nfunction changeColor( color : Color){ # typeで宣言したstateのみを許容する\n} \n```\n\n## Type Guard\n\n\nオブジェクト内に格納されているキーを判別してそれぞれの機能を実行\n\n```\ntype Dog = {\n\t**bark: ()** => console.log(‘bark’)\n}\n\ntype Cat = {\n\t**meow:** () => console.log(‘meow’)\n}\n\nfunction animalSound ( animal : Dog | Cat ) {\n\tif (**‘bark’ in animal**) return animal.bark()\n\tif (**‘meow’ in animal**) return animal.meow()\n)\n```\n\n## interfaceでの型宣言\ntypeとは異なりtypeNameの後ろに=がいらない\n```\n**interface Name {**\n\tname: string\n}\n```\n### class, methodの型宣言\n```\ninterface Name {\n\t**log : (name : string) => void**\n}\n```\n\n### classへの型割り当て\nclass名の後に**imprements interface名**を追加\n\n```\nclass ConsoleLog **imprements Name** {\n\tlog(name : string) {\n\tconsole.log(name)\n\t}\n}\n```\n\n### 型の拡張\n\nextends inteface名で型を拡張することができる\n```\ninterface Name **extends LastName** {\n\tfirstName : string\n}\ninterface LastName {\n\tlastName : string\n}\nconst fullName : **Name** = {\n\tfirstName = ‘taro’\n\tlastName = ‘sato’\n}\n```\n### index の型宣言\nobject名が未確定な場合などにプロパティ名を指定して型宣言する\n```\ninterface Product {\n\t**[category: string] : number** # number型のobjectをstringのcategoryとして解釈する\n}\n```\n","createdAt":"2022-07-15T02:43:51.037Z","updatedAt":"2022-07-30T03:48:10.442Z","publishedAt":"2022-07-15T02:43:51.810Z","tag1":"TypeScript","tag2":"React.js","tag3":null,"tag4":null,"tag5":null,"description":"そろそろTypeScriptに手を出す。覚えたい基礎とか色々とメモ。"}},{"id":11,"attributes":{"title":"指定した要素の位置に画面スクロールする関数","content":"## 画面スクロール関数\n```\nfunction scroll (num = 0) {\n\twindow.scrollTo({ top: num, behavior: \"instant\" }); #behaviorをsmoothにすると画面移動が滑らかになる。\n};\n```\n## 要素の位置を取得する関数\n```\nfunction getTopByElementId( id ) {\n　　　const element = document.getElementById(id); #例として要素をidで取得\n　　　const rect = element.getBoundingClientRect().top;　#画面内の要素の位置を取得\n　　　const scroll = window.scrollY #ページのスクロール量を取得\n　　　const top =  scroll + rect; #ページのスクロール量と画面内の要素の位置を足すことで、ページ全体からの要素位置を取得\n　　　return top\n}\n```\n## ページの要素位置を取得しそこまで移動する\n先ほどの関数を掛け合わせれば完成。\n```\nscroll(getTopByElementId('id'))\n```","createdAt":"2022-07-16T09:06:02.630Z","updatedAt":"2022-07-16T09:10:22.077Z","publishedAt":"2022-07-16T09:06:05.172Z","tag1":"JavaScript","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"何かと便利な指定した要素へ画面スクロールする関数。"}},{"id":12,"attributes":{"title":"スクロール量に合わせて要素を上下に動かす関数","content":"## 要素のポジションを取得する関数\n\n### 引数\n**query** = エフェクトを与える固有の要素を指定 ex, \".element\"\n\n**num** = 要素のheightを基準にした上下幅の動きの割合\n```\nfunction scrollElement(query, num) { \n\tconst el = document.querySelector(query);　#エフェクトを与える要素を取得\n\tconst rect = el.getBoundingClientRect();　#要素のサイズプロパティを取得\n\n\tconst elementPosition = rect.y + rect.height / 2;　#要素の中央の位置を取得\n\tconst windowHeight = window.innerHeight / 2;　#windowの画面サイズの中央の値を取得\n\n\tlet percentage = ((windowHeight - elementPosition) / windowHeight) * num;　#画面中央から要素がどれだけ離れているかを取得\n\tif (percentage > num) percentage = num;　\n\tif (percentage < -1 * num) percentage = -1 * num;\n\n\tel.style.transform = `translateY(${percentage}%)`;　#要素のtransformの値を変更する\n}\n```\n\n## eventListenerとして実装\n```\ndocument.addEventListener(**\"scroll\", () => scrollElement(\".element\", 50)**);\n```","createdAt":"2022-07-16T19:48:23.862Z","updatedAt":"2022-07-16T23:20:42.663Z","publishedAt":"2022-07-16T19:48:27.136Z","tag1":"JavaScript","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"スクロール量に合わせて要素を上下移動。少しおしゃれなウェブサイト向け。"}},{"id":13,"attributes":{"title":"静的HTMLをローカル環境で確認する #Next.js","content":"## serveの利用\nNext.jsで出力した静的HTMLに直接アクセスすると、ライブラリの参照元がずれて正確にサイトが表示されない。\n\n解決策として、簡易的なサーバーを立ち上げられるserveを利用してHTMLを表示する。\n## 必要なライブラリのインストール\n```\nnpm i serve\n```\n\n## Next.jsのpackage.jsonに変更を加える\n```\n\"scripts\": {\n\t\t\"build\": \"next build && next export\", #build後に静的HTMLをフォルダ内の **./out** に出力\n\t\t\"serve\": \"serve ./out\" #serveの参照先を静的HTMLが出力されたフォルダに設定\n\t},\n```\n\n## ターミナル内の実行\n```\nnpm run build　#静的ファイルのbuildとexport\nnpm run serve #サーバーで静的HTMLを表示\n```\n\n最後に、ターミナルに表示されるlocalhostのURLにchromeでアクセス。","createdAt":"2022-07-16T21:38:03.324Z","updatedAt":"2022-07-17T21:41:41.378Z","publishedAt":"2022-07-16T21:39:24.708Z","tag1":"Next.js","tag2":null,"tag3":null,"tag4":null,"tag5":null,"description":"直接開くと正しく動作しないNext.jsの静的HTMLをローカル環境で確認する方法。"}},{"id":14,"attributes":{"title":"Framer Motion で上下のParallaxを実装する #React.js","content":"## ライブラリのインストール\n```\nnpm i framer-motion\n```\n\n## import\n```\nimport React, { useRef } from \"react\";\nimport { motion, useScroll, useSpring, useTransform } from \"framer-motion\";\n```\n\n## 必要な関数\n\nvalue: scrollYProgressを指定する\n\nrange: 動かす上下範囲を指定: number\n\n```\nfunction useParallax(value, range) {\n  return useTransform(value, [0, 1], [-range, range]);\n}\n```\n\n## 上下に動かす要素内の実装\n\n```\nconst Element = ({ num }) => {\n\tconst ref = useRef(null);\n\tconst { scrollYProgress } = useScroll({ target: ref }); # refを参照してscrollの相対位置を取得\n\tconst Y = useParallax(scrollYProgress, 300); # 要素を動かす最大上下範囲を指定px: number\n\tconst y = useSpring(Y, { stiffness: 100, damping: 20, mass: 1 }); # 慣性を加える\n\nreturn (\n\t\t< section>\n\t\t\t< div className=\"flex\" ref={ref}> #相対的なscroll位置を取得するためのrefを設定\n\t\t\t\t< motion.h2 className=\"box\" style={{ y }}>動かす要素</motion.h2> #動かす要素にmotionとstyleを設定\n\t\t\t< /div>\n\t\t< /section>\n\t);\n};\n```\n## CodeSandBox\n\n```\n<iframe src=\"https://codesandbox.io/embed/dank-fast-y4n168?autoresize=1&fontsize=12&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"dank-fast-y4n168\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n```","createdAt":"2022-07-29T06:21:34.052Z","updatedAt":"2022-07-29T07:31:26.652Z","publishedAt":"2022-07-29T06:23:25.154Z","tag1":"FramerMotion","tag2":"React.js","tag3":"Next.js","tag4":null,"tag5":null,"description":"慣性を含めた上下ParallaxをFramer Motionで実装していく。"}},{"id":15,"attributes":{"title":"useFormでEmailが有効な形式が判断する #React.js","content":"## ライブラリのインストール\n\n\n```\nnpm i react-hook-form\n```\n## import\n```\nimport { useForm } from ‘react-hook-form’\nimport { useState } from 'react'\n```\n\n## 必要な定数を宣言\n\n\n```\nconst {  \n　　register,  \n　　handleSubmit,  \n　　formState: { errors },  \n} = useForm();\n\nconst [emailValue, setEmailValue] = useState(\"\");\n```\n\n## Emailが有効な形式か判断する正規表現\n```\n/^[a-zA-Z0-9_+-]+(.[a-zA-Z0-9_+-]+)*@([a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\\.)+[a-zA-Z]{2,}$/\n```\n\n## useForm用のpattern\n```\npattern: {\n\tvalue: /^[a-zA-Z0-9_+-]+(.[a-zA-Z0-9_+-]+)*@([a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\\.)+[a-zA-Z]{2,}$/,\n\tmessage: \"有効なメールアドレス形式で入力してください\",\n},\n```\n\n## onChangeでかな文字入力を不可にする関数\n```\n  function onChangeEmail({ target }) {\n    const targetValue = target.value.replace(/\\s|[^@_.a-zA-Z0-9]/g, \"\");\n    setEmailValue(targetValue);\n  }\n```\n\n\n## submit時の処理を設定\n```\nconst onSubmit = async (data) => {\n\tconst response = await fetch(\"url\", {\n\t\tmethod: \"POST\",\n\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\tbody: JSON.stringify(data),\n\t});\n\n\tif (response.ok) {\n\t\tconsole.log(\"success\");\n\t} else {\n\t\tconsole.log(\"fail\");\n\t}\n};\n```\n\n\n## form内の実装\n```\n< form>\n\t< input\n\t\ttype=\"text\"\n\t\tvalue={emailValue}\n\t\t{...register(\"email\", {\n\t\t\trequired: {\n\t\t\t\tvalue: true,\n\t\t\t\tmessage: \"この項目は必須です\",\n\t\t\t},\n\t\t\tpattern: {\n\t\t\t\tvalue: /^[a-zA-Z0-9_+-]+(.[a-zA-Z0-9_+-]+)*@([a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\\.)+[a-zA-Z]{2,}$/,\n\t\t\t\tmessage: \"有効なメールアドレス形式で入力してください\",\n\t\t\t},\n\t\t})}\n\t\tonChange={onChangeEmail}\n\t/>\n\t< button onClick={handleSubmit(onSubmit)}>send</button>\n\t{errors?.email && < div>{errors.email?.message}< /div>}\n< /form>\n```\n\n## codesandbox\n```\n<iframe src=\"https://codesandbox.io/embed/email-validation-on-form-zb6kun?fontsize=12&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"Email validation on Form\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n```\n\n","createdAt":"2022-07-30T03:00:25.799Z","updatedAt":"2022-07-30T03:51:56.819Z","publishedAt":"2022-07-30T03:00:27.935Z","tag1":"React.js","tag2":"Next.js","tag3":null,"tag4":null,"tag5":null,"description":"Form内のemail形式をuseFormで判定してみる。"}},{"id":16,"attributes":{"title":"Chakra-UIとFramer-Motionを統合するcomponent","content":"## ライブラリのインストール\n```\nnpm i @chakra-ui/react framer-motion\n```\n\n## component内の実装\n```\nimport { motion, isValidMotionProp } from \"framer-motion\";\nimport { chakra } from \"@chakra-ui/react\";\n\nconst Motion = chakra(motion.div, {\n  shouldForwardProp: (prop) => isValidMotionProp || prop === \"children\"\n});\n\nexport default Motion;\n```\n\n## 実際の利用\n```\nimport React from \"react\";\nimport Motion from \"./Motion\";\n\nexport default function App() {\n  return (\n    < Motion  #通常のchakra と framer-motionのpropsを両方利用できるようになる\n        w='full'\n        textAlign='center'\n        initial={{ y: 100 }}\n        animate={{ y: 0 }}\n        transition={{ duration: 1 }}\n    >\n      < p>test< /p> #animationを加える要素を囲む\n    < /Motion>\n  );\n}\n```\n\n## codesandbox\n```\n<iframe src=\"https://codesandbox.io/embed/flamboyant-cdn-co361p?fontsize=12&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"flamboyant-cdn-co361p\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n```","createdAt":"2022-08-01T06:46:52.538Z","updatedAt":"2022-08-01T06:53:30.248Z","publishedAt":"2022-08-01T06:46:53.300Z","tag1":"ChakraUI","tag2":"FramerMotion","tag3":"React.js","tag4":"Next.js","tag5":null,"description":"chakra-UIとFramer-Motionを統合してcomponentの使い勝手を良くする。"}}]