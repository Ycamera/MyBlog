[{"id":1,"attributes":{"title":"マークダウンをReactのJSXに変換","content":"## remarkの利用\nReactであれば、マークダウンを渡すだけでJSXに変換される \"react-markdown\"が便利。\n\nしかし、今回はマークダウン内の一部の要素を途中で書き換えたかったので、\"remark\"を利用する。\n\n## ライブラリをインストール\n```\nnpm install unified remark-parse remark-rehype rehype-sanitize rehype-stringify\n```\n\n## JavaScriptのファイル内にimport\n```\nimport { unified } from \"unified\";\nimport remarkParse from \"remark-parse\";\nimport remarkRehype from \"remark-rehype\";\nimport rehypeSanitize from \"rehype-sanitize\";\nimport rehypeStringify from \"rehype-stringify\";\n```\n\n\n## マークダウンをJSXに変換してreturnする関数\nhtml変換後のデータを直接Reactに渡すと、JSXではなく文字列として認識される。\n\nそのため、dangerouslySetInnerHTMLを利用してJSXに埋め込むかたちでreturnする必要がある。\n```\nasync function convertMarkdownIntoHtml(markdown) {\n\n\tconst data = await unified()\n\t\t.use(remarkParse)\n\t\t.use(remarkRehype)\n\t\t.use(rehypeSanitize)\n\t\t.use(rehypeStringify)\n\t\t.process(markdown);\n\n\tconst html = data.value　#ここからreplaceを使い自由に要素を書き換えられる。\n    \n\treturn <div dangerouslySetInnerHTML={{ __html: html }}></div>;  #JSXに埋め込んでreturn\n}\n```","createdAt":"2022-07-05T19:02:18.818Z","updatedAt":"2022-07-08T21:16:42.990Z","publishedAt":"2022-07-05T19:36:33.320Z","tag1":"JavaScript","tag2":"React.js","tag3":"Next.js","tag4":null,"tag5":null,"description":"remarkを用いてマークダウンをJSXに変換しちゃおう。"}},{"id":4,"attributes":{"title":"CSSでスクロールバーをカスタマイズ","content":"## スクロールバーのプロパティ\n\n```\n::-webkit-scrollbar　#縦横幅の設定\n::-webkit-scrollbar-track　#背景部分\n::-webkit-scrollbar-thumb 　#スクロールバー本体\n```\n\n\n## プロパティの設定\n```\n::-webkit-scrollbar {\n\twidth: 10px;　#Y軸の横幅\n\theight: 10px;　#X軸の縦幅\n}\n\n::-webkit-scrollbar-track {\n\tbackground: #好みの色;\n}\n\n::-webkit-scrollbar-thumb {\n\tbackground: #好みの色;\n\tborder-radius: 50px;　#丸みを帯びさせる\n\tborder: solid 1px #好みの色;　背景色と同じ色にすると左右に隙間ができ、デフォルトのスクロールバーの形式に近づく \n}\n```\n","createdAt":"2022-07-06T23:55:38.217Z","updatedAt":"2022-07-08T21:16:21.077Z","publishedAt":"2022-07-06T23:56:04.602Z","tag1":"CSS","tag2":"SCSS","tag3":null,"tag4":null,"tag5":null,"description":"おしゃれなスクロールバーが作れるかも。"}},{"id":5,"attributes":{"title":"Next.jsでメタ要素の設定を簡単に","content":"## メタ要素の入力をComponent化する\n\n```\nimport Head from \"next/head\";\n\nexport default function MyHead({ url, type, title, description, image, children }) {\n\treturn (\n\t\t<Head>\n\t\t\t{url && <meta property=\"og:url\" content={url} />}　#URL\n\t\t\t{type && <meta property=\"og:type\" content={type} />}　#ページの種類 website or article\n\t\t\t{title && <meta property=\"og:title\" content={title} />}　#そのページのタイトル（サイトネームとは別）\n\t\t\t{image && <meta property=\"og:image\" content={image} />}　#サムネ\n\t\t\t{description && (　#ページの説明\n\t\t\t\t\t<>\n\t\t\t\t\t<meta property=\"og:description\" content={description} />\n\t\t\t\t\t<meta name=\"description\" content={description} />\n\t\t\t\t\t</>\n\t\t\t)}\n\t\t\t{children}　#子要素を含める\n\t\t</Head>\n\t);\n}\n```","createdAt":"2022-07-07T16:40:27.934Z","updatedAt":"2022-07-08T21:17:52.806Z","publishedAt":"2022-07-07T16:40:29.260Z","tag1":"JavaScript","tag2":"Next.js","tag3":"SEO","tag4":"React.js","tag5":null,"description":"ページごとにメタ要素を楽に設定できるComponent。"}},{"id":6,"attributes":{"title":"display: flexでサイドバーを作る","content":"## flexを使う理由\n固定的なサイドバーはgridで簡単に実装できる。\n\nしかし、今回はサイドバーを可変式にしたかったので、使い勝手のいいflexで実装する。\n\n## HTML\n```\ndiv class=\"flex\">　#親要素のflex\n\t<div class=\"sidebar\">sidebar</div>　#サイドバー\n\t<div class=\"content\">content</div>　#コンテンツ\n</div>\n```\n\n## CSS\n```\n.flex {\n\tdisplay: flex;　#親要素にflexを設定\n}\n\n.sidebar {\n\twidth: 300px;　#子要素のサイドバーの横幅を設定\n}\n\n.content {\n\tflex: 1;　#サイドバーで埋まらなかった親要素の余白をコンテンツのwidthに設定\n}\n\n```","createdAt":"2022-07-08T20:54:57.178Z","updatedAt":"2022-07-08T23:37:55.220Z","publishedAt":"2022-07-08T20:54:57.902Z","tag1":"CSS","tag2":"SCSS","tag3":null,"tag4":null,"tag5":null,"description":"使い勝手のいいflexでブログのサイドバーを実装する。"}},{"id":7,"attributes":{"title":"Framer motionでReactのマウスカーソルをカスタマイズする","content":"## 必要なライブラリのインストール\n```\nnpm install framer-motion @react-hook/mouse-position\n```\n\n## JavaScriptにimport\n```\nimport { motion } from \"framer-motion\";\nimport useMouse from \"@react-hook/mouse-position\"\n```\n\n## 必要なStateとRef\n```\nconst [cursorText, setCursorText] = useState(\"test\");　#テキスト保存用のstate\nconst [cursorVariant, setCursorVariant] = useState(\"default\");　#Framer Motionで変数を指定するときに使うstate\n\nconst ref = React.useRef(null);\n```\n\n## マウスの位置を取得\n```\nconst mouse = useMouse(ref, {　#importしたuseMouseを代入\n\tenterDelay: 100,　#カーソルの遅延度\n\tleaveDelay: 100,\n});\n\n#マウスの座標\nlet mouseX = 0;\nlet mouseY = 0;\n    \n#マウスが画面内にあるときに、その座標を代入\nif (mouse.x !== null) mouseX = mouse.clientX;\nif (mouse.y !== null) mouseY = mouse.clientY;\n```\n    \n## Framer motion用の変数\n```\nconst variants = {\n\tdefault: {　#animateの初期値\n\t\topacity: 0,\n\t\theight: 0,\n\t\twidth: 0,\n\t\tx: mouseX,　#ここで取得したマウス座標を設定する\n\t\ty: mouseY,\n\t\tfontSize: \"1rem\",\n\t},\n\n\tlink: {　#リンクホバー時にカーソルを拡大\n\t\topacity: 1,\n\t\theight: 50,\n\t\twidth: 50,\n\t\tx: mouseX,\n\t\ty: mouseY,\n\t\tfontSize: \"1.2rem\",　#フォントサイズの変更\n\t},\n\n\tspring: {　#transitionに設定するとバネのような挙動になる\n\t\tdamping: 10,　#バネの抵抗力　0だと永遠に振動する\n\t\tmass: 1,　#重力　値が高いほど無重力に\n\t},\n};\n```\n\n## 要素上でカーソルにエフェクトを加える関数\n```\nfunction mouseOverLink() {　#マウスホバー時\n\tsetCursorText(\"view\");　#カーソル内のテキストを設定\n\tsetCursorVariant(\"link\");　#variants内のカーソルのmotionを指定\n}\n\nfunction mouseLeave() {　#マウスが要素を離れた時\n\tsetCursorText(\"\");　#カーソル内のテキストをリセット\n\tsetCursorVariant(\"default\");　#カーソルのmotionをデフォルトへ戻す\n}\n```\n\n## Reactのレンダー部分\n```\nfunction MouseCursorLayout({ children }) {\n    \n    #...先ほどまでの要素を内部に組み込む\n\n\treturn (\n\t\t<div ref={ref}>　#refをhtmlに設定　※カーソルが機能するのはrefを設定したhtml内部のみ\n\n            #Framer motionの変数にvariantsを設定、animateにvariant指定用のstateを設定する\n\t\t\t<motion.div className=\"mouse-cursor\" variants={variants} animate={cursorVariant}>\n\t\t\t\t<div className=\"mouse-cursor-box\">\n\t\t\t\t\t<span className=\"mouse-cursor-text\">{cursorText}</span>　#カーソルに表示されるテキスト\n\t\t\t\t</div>\n\t\t\t</motion.div>\n\t\t\t{children}　#Componentとして渡した要素を表示する　メインコンテンツなど\n\t\t</div>\n\t);\n}\n\n```\n## CSSの設定\n```\n.mouse-cursor {\n\tz-index: 500;\n\tposition: fixed;\n\tdisplay: flex;\n\talign-content: center;\n\tjustify-content: center;\n\tleft: 0;\n\ttop: 0;\n\theight: 0px;\n\twidth: 0px;\n\tpointer-events: none;\n}\n\n.mouse-cursor-box {\n\tbackground-color: $blue400;\n\tcolor: white;\n\tborder-radius: 50%;\n\twidth: 100%;\n\theight: 100%;\n\toverflow: hidden;\n}\n\n.mouse-cursor-text {\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: flex;\n\talign-items: center;\n\tfont-weight: bold;\n\tjustify-content: center;\n}\n```","createdAt":"2022-07-08T23:57:23.006Z","updatedAt":"2022-07-11T15:02:43.819Z","publishedAt":"2022-07-09T00:22:00.325Z","tag1":"React.js","tag2":"Next.js","tag3":"CSS","tag4":null,"tag5":"FramerMotion","description":"オリジナルカーソルでWEBサイトのデザイン性を高めてみよう。"}},{"id":8,"attributes":{"title":"Framer Motionでページ遷移のエフェクトを作る　#Next.js","content":"## ライブラリのインストールとimport\n\n```\nnpm install motion\n```\n```\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { useRouter } from \"next/router\";#ページ遷移の検知に必要\n```\n\n## Next.js、_app.js内の実装\ncomponentの離脱を検知するためにAnimatePresenceで子要素を囲む\n```\nfunction MyApp({ Component, pageProps }) {\n\tconst router = useRouter();　#現在のページを検知するためにルートを読み込む\n\n\treturn ( \n\t\t<AnimatePresence exitBeforeEnter>#Componentの離脱を検知するためにexitBeforeEnterが必要\n\t\t\t<Component {...pageProps} key={router.asPath} />#ページ遷移を検知するために現在のURLをKeyに設定\n\t\t</AnimatePresence>\n\t);\n}\n\n```\n\n## Layout内の実装\nFramer Motionのアニメーションをcomponentに組み込む\n```\nexport default function Layout({ children }) {\n\treturn (\n\t\t<motion.div　#ページ遷移時のエフェクトを設定\n\t\t\tinitial={{ opacity: 0, y: 10 }}#ページ読み込み前\n\t\t\tanimate={{ opacity: 0, y: 10 }}#ページ読み込み完了後\n\t\t\texit={{ opacity: 0, y: 10 }}#ページ離脱時\n\t\t\ttransition={{ duration: 0.4 }}#アニメーションの時間\n\t\t>\n\t\t\t{children}\n\t\t</motion.div>\n\t);\n}\n```\n\n## pagesのcomponent内の実装\n先ほどのLayoutをページコンテンツの親コンポーネントに設定する。\n```\nimport Layout from \"./保存先\"\n\nexport default function Home() {\n\treturn (\n\t\t<Layout>\n\t\t\t<div>Content</div>#ページ内に表示されるコンテンツ\n\t\t</Layout>\n\t);\n}\n```","createdAt":"2022-07-10T00:11:15.969Z","updatedAt":"2022-07-10T00:53:30.613Z","publishedAt":"2022-07-10T00:36:07.136Z","tag1":"FramerMotion","tag2":"React.js","tag3":"Next.js","tag4":null,"tag5":null,"description":"ページ遷移エフェクトに必要な、AnimatePresenceの使い方を覚えてみる。"}}]